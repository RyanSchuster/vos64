<head>
<title>VOS64 Documentation</title>
</head>
<body>

<h1>VOS64 Documentation</h1>
<p>You're welcome.</p>

<h2>Contents:</h2>
<ul>
	<li>About VOS64</li>
	<li>Building from Sauce</li>
	<li>Static Memory Map</li>
	<li>Startup Process</li>
	<li>File/Folder Tree</li>
	<li>Code Style Guide</li>
</ul>


<h2>About VOS64</h2>

<p>VOS64 is the 64-bit Vos Operating System. The name is <i>not</i> a recursive
acronym -- it is named after the legendary Mr. Vos. It has been speculated that
there is no chin under Mr. Vos's beard -- only another beard.</p>

<p>The goal of VOS is to be more unix than Unix.</p>


<h2>Building from Sauce</h2>

<p>The sauce is written in x86_64 assembly in intel syntax with NASM
precompiler syntax. Building with NASM has not been tested - only YASM has been
used.</p>
<p>At the time of writing, YASM (version 1.3.0) has a bug where it will not
produce sign extended 32-bit relocations (type <code>R_X86_64_32S</code> in
<code>objdump</code> output and YASM source), only non-sign extended
relocations (type <code>R_X86_64_32</code>). YASM needs to be compiled with a
kludge to get around this and build the VOS binary.</p>
<p>The problem can be worked around by modifying (in the YASM source package)
<code>modules/objfmts/elf/elf-x86-amd64.c</code> to always return
<code>R_X86_64_32S</code> type relocations instead of <code>R_X86_64_32</code>.
This is on line 185 in the 1.3.0 source package. If it's not there, then
"<code>grep -n -r R_X86_64_32 .</code>" at the command line in the YASM source
root directory should find it for you, whereever it is. If that grep command
returns any instances of <code>R_X86_64_32S</code> anywhere other than header
files in newer versions of YASM, then the bug has probably been fixed. In that
case, don't modify the code or else it will be wrong. In fact, it's still wrong
in version 1.3.0 after the mod, because then it never produces the
<code>R_X86_64_32</code> relocation. We just don't care about that for VOS.</p>
<p>If you don't want to install your new, differently-broken version of YASM,
you'll need to modify the "<code>AS = yasm</code>" line of VOS's Makefile to
point to your new YASM build.</p>
<p>Once YASM is ready to go, typing
<blockquote><code>make</code></blockquote>
from the command line in the root directory will build the binary,
<blockquote><code>make clean</code></blockquote>
will delete the binary and all object files, and
<blockquote><code>make install</code></blockquote>
will generate a bootable cd image with the contents of the
<code>media/cd/iso/</code> directory. It will output
<code>media/cd/vos_boot_cd.iso</code></p>
<p>GRUB at the time of writing (2.02b2) likes to choke on 64-bit elf files.
It's entirely possible, and in fact likely, that it's my fault for doing
something wrong. That being said, I haven't been able to get it to load, and
the multiboot standard hasn't been updated to the amd64 arch anyway, so the
final output binary is in <code>elf32-i386</code> format. The 64-bit code is
still linked-in just fine, but good luck debugging without a proper symbol
table.</p>


<h2>Static Memory Map</h2>

<table border="1">
	<tr>
		<td><b>Physical (Load) Address</b></td>
		<td><b>Output file sections</b></td>
		<td><b>Source file sections</b></td>
		<td><b>Important symbols</b></td>
		<td><b>Description</b></td>
	</tr>
	<tr>
		<td>0x00000000</td>
		<td></td>
		<td></td>
		<td></td>
		<td>Basic PC stuff, probably also used by GRUB during boot</td>
	</tr>
	<tr>
		<td>0x00100000</td>
		<td>strapon</td>
		<td>straponHeaders</td>
		<td></td>
		<td>This is where the "strapon" 32-bit-to-64-bit code is
		loaded. The "straponHeaders" section contains the multiboot
		header and is placed at the beginning of the "strapon" section
		of the output binary so GRUB can find it.</td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td>straponText</td>
		<td></td>
		<td>This section contains the strapon code. It's a mix of 32-
		and 64-bit code.</td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td>straponData</td>
		<td></td>
		<td>This section contains initialized data for the strapon
		section.</td>
	</tr>
	<tr>
		<td></td>
		<td>straponBss</td>
		<td>straponBss</td>
		<td></td>
		<td>This section contains uninitialized data for the strapon
		section.</td>
	</tr>
	<tr>
		<td>0x00200000</td>
		<td>.text</td>
		<td>.text</td>
		<td></td>
		<td>This section contains 64-bit code for the kernel-proper.
		</td>
	</tr>
	<tr>
		<td></td>
		<td>.data</td>
		<td>.data</td>
		<td></td>
		<td>This section contains initialized data for the
		kernel-proper.</td>
	</tr>
	<tr>
		<td></td>
		<td>.bss</td>
		<td>.bss</td>
		<td></td>
		<td>This section contains uninitialized data for the
		kernel-proper.</td>
	</tr>
	<tr>
		<td></td>
		<td>.reclaim</td>
		<td>.reclaimText</td>
		<td></td>
		<td>The .reclaim section contains parts of the kernel that will
		only be used during initialization. This space is later
		"reclaimed" as usable memory. The .reclaimText section contains
		code that is reclaimable.</td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td>.reclaimData</td>
		<td></td>
		<td>This section contains reclaimable initialized data space.
		</td>
	</tr>
	<tr>
		<td></td>
		<td>.reclaimBss</td>
		<td>.reclaimBss</td>
		<td></td>
		<td>This section contains reclaimable uninitialized data space.
		</td>
	</tr>
</table>


<h2>Startup Process</h2>

<ol>
	<li>Extra bootloader "strapon" process
		<ol>
			<li>GRUB loads the kernel binary and jumps to the
			beginning of the strapon code in 32-bit mode.</li>
			<li>The strapon sets up a temporary stack and saves off
			some multiboot stuff.</li>
			<li>The strapon sets up amd64 paging structures to
			identity map the strapon memory and map the kernel
			memory to upper memory.</li>
			<li>The strapon enters 64-bit long mode using its
			temporary paging tables and a temporary GDT.</li>
			<li>The strapon restores the important multiboot stuff,
			clears out all the general-purpose registers, and jumps
			to the kernel entry point in upper memory.</li>
		</ol>
	</li>
	<li>Kernel initialization process
		<ol>
			<li>Kernel sets up a temporary stack</li>
		</ol>
	</li>
</ol>


<h2>File/Folder Tree</h2>

<ul>
	<li>bin
		<p>Location of the kernel binary after build</p>
	</li>
	<li>doc
		<p>Location of documentation</p>
	</li>
	<li>media
		<p>Location of bootable media images</p>
		<ul>
			<li>cd
			</li>
		</ul>
	</li>
	<li>src</li>
	<li>obj</li>
	<li>inc</li>
<ul>

</body>
